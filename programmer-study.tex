\chapter{AFABL Programmer Study}\label{ch:programmer-study}

\section{Experiments}

Programmers were randomly assigned to two equally-sized groups: one group used Scala without AFABL first -- the Scala-first group -- and the other group used AFABL first -- the AFABL-first group.  Each group completed two programming tasks using Scala and AFABL in the order determined by their group.  For each task the programmers were asked to design and implement elegant code that meets the requirements of the task as quickly as possible, balancing the quality of their solutions with time.  The idea is to get a good solution quickly, not a perfect solution in a long time.

\subsection{Task 1: The Bunny-Wolf Domain}\label{sec:task1}

\begin{figure}[h]

\begin{center}
\includegraphics[height=2.4in]{bunny.png}
\end{center}


\caption{In the grid world above, the bunny must pursue two goals
  simultaneously: find food and avoid the wolf.  The bunny may move
  north, south, east, or west.  When it finds food it consumes the
  food and new food appears elsewhere in the grid world, when it meets
  the wolf it is eaten and ``dies.''}
\label{fig:bunny-picture}
\end{figure}

In this task each programmer wrote an agent that controls a bunny character in a simple
world, depicted in Figure~\ref{fig:bunny-picture}.  The bunny world works as follows:

\begin{itemize}

\item The bunny world is a discrete grid of cells.  The bunny, wolf, and food each occupy one cell.

\item During each time step the bunny may move north, south, east, or west.

\item Every two time steps the wolf moves towards the bunny.

\item If the bunny moves to the cell currently occupied by the food, the bunny eats the food, receives a signal from the simulation that it has eaten the food, and new food appears elsewhere.

\item If the wolf moves to the cell currently occupied by the bunny it eats the bunny and the episode ends.

\end{itemize}

The simulation runs several episodes, keeping track of how much food the bunny eats and how long (how many time steps) the bunny ``lives'' in each episode.  Programmers will be asked to write bunny agents that live as long as possible and eat as much food as possible.

\subsection{Task 2: Mating Bunny}\label{sec:task2}

In this task each programmer will write a bunny agent for a world that is identical to the world in Task 1 except that the bunny must also find mates.  The world will include one static  potential mate that behaves similarly to the food.  When the bunny finds the potential mate, the bunny receives a signal that it has ``mated,'' the mate disappears (because it goes off to have babies), and another potential mate appears elsewhere.  The simulation runs as in Task 1, additionally keeping track of how many mates the bunny finds.  As in Task 1, programmers will be asked to write bunny agents that live as long as possible, eat as much food as possible, and find as many mates as possible.

%% \subsection{Task 3: Adding Wind, Spoiling Food, and Picky Mates}\label{sec:task3}

%% In this task each programmer will write a bunny agent for a world with the same elements as in Task 2 and with the same goals for the bunny, but the world is more complex.  In particular:

%% \begin{itemize}

%% \item There is constant wind from an unchanging direction that affects the wolf's ability to find the bunny.  The wolf will only move toward the bunny if the wolf is downwind of the bunny.

%% \item If food is not eaten within 15 time steps after it appears, it spoils.  Spoilage is represented by the food disappearing and new food appearing elsewhere.

%% \item To simulate selection of fit bunnies, potential mates will only accept the bunny if the bunny has eaten within 10 time steps (a hungry bunny is an unsuccessful bunny and therefore not fit for mating).  Rejection will be represented by the potential mate remaining in place and the bunny not receiving a signal that mating has occurred.

%% \end{itemize}



\section{Data Collection}

Data were collected from programmers in three ways: directly through questionnaires and surveys, automatically with a custom-developed IntelliJ IDEA plug-in that tracked time and submitted solutions, and independently through static and dynamic analysis of programmers' submitted solutions to the programming tasks \cite{singer2008a-software}.  The following sections discuss each of the data collection methods.

\subsection{Programmer Demographics Survey}

The demographics survey was be given to participants after they read and agreed to the consent form and before they were given task instructions and assigned to groups.

\paragraph{Purpose}

The purpose of this survey was to place the programmers in groups according to their programming experience and skills.  In particular, the web application used this survey to assign participants to the Scala-first and AFABL-first groups so that each group had similar distributions of programmer experience and skill levels.  Survey results were also used to develop other quantitative and qualitative measures relating demographic information to task performance.

\paragraph{Questionnaire}

\begin{enumerate}

\item What is your level of education?

\begin{enumerate}
\item High School
\item Associate Degree, or currently enrolled in Bachelor degree program
\item Bachelor Degree
\item Master Degree
\item Doctoral Degree
\end{enumerate}

Rationale: education level can affect programming proficiency.

\item What is your most applicable college major? By “most applicable” we mean the major you are using most in your profession. For example, if you got a B.S. in electrical engineering and a M.S. in computer science and work as a software engineer, then your most applicable major is computer science.

Rationale: college major can affect programming proficiency.  Additionally, we may code the data to distinguish between technical (but not necessarily computer science) and non-technical majors.

\item Number of years of professional programming experience. You may include years spent working on graduate research projects. Count a semester as .5 years.

Rationale: programming experience can affect programming proficiency.

\item How proficient are you at game/agent programming?  
\begin{enumerate}
\item Not proficient
\item Familiar (have done tutorials or simple examples)
\item Proficient (can write programs with multiple objects and files)
\item Expert
\end{enumerate}

Rationale: game/agent programming proficiency is not common in the general programmer population.  Knowing programmers’ proficiencies in game/agent programming will help randomize the experiment groups and allow additional inferences relating game/agent programming proficiency and proficiency with AFABL.

\item How proficient are you at Scala programming?  
\begin{enumerate}
\item Not proficient
\item Familiar (have done tutorials or simple examples)
\item Proficient (can write programs with multiple objects and files)
\item Expert
\end{enumerate}

Rationale: Scala is our baseline language, and AFABL is embedded in Scala.  Scala proficiency will have a profound effect on task proficiency and thus needs to be accounted for in randomizing the experiment groups.

\end{enumerate}


\subsection{Reflection Survey}

The purpose of the reflection survey is to develop a qualitative assessment of programmer satisfaction with AFABL.

\paragraph{Questionnaire}

For each question, select the degree to which you agree with the statement based on
the agent programming tasks you completed for this experiment.

\begin{enumerate}
\item I have a positive impression of agent programming in AFABL.

\begin{enumerate}
\item Strongly disagree
\item Disagree
\item Neutral
\item Agree
\item Strongly Agree
\end{enumerate}

Rationale: programmers’ impression of Scala will provide a baseline for evaluating
programmers’ impression of AFABL.

\item I found it easier to write the agents using AFABL’s programming constructs compared to bare Scala.

\begin{enumerate}
\item Strongly disagree
\item Disagree
\item Neutral
\item Agree
\item Strongly Agree
\end{enumerate}

Rationale: the point of AFABL is to facilitate agent programming, so programmers should have a more positive impression of AFABL for agent programming.

\item I believe that AFABL facilitated more reusable and maintainable code for agents compared to bare Scala.

\begin{enumerate}
\item Strongly disagree
\item Disagree
\item Neutral
\item Agree
\item Strongly Agree
\end{enumerate}

Rationale: answers to this question should correlate with answers to Question 1.

\item If given the choice, I would choose AFABL over Scala for agent programming projects.

\begin{enumerate}
\item Strongly disagree
\item Disagree
\item Neutral
\item Agree
\item Strongly Agree
\end{enumerate}

Rationale: answers to this question should correlate with answers to Question 2.

\item I found it easier to use AFABL compared to Scala for Task 1.

\begin{enumerate}
\item Strongly disagree
\item Disagree
\item Neutral
\item Agree
\item Strongly Agree
\end{enumerate}

Rationale: in addition to objective analyses of task submissions, we want to know whether programmers subjectively prefer AFABL.

\item What was it about AFABL that made the Task 1 easier or harder?

Rationale: we want to get open-ended feedback for things we did not anticipate.

\item I found it easier to use AFABL compared to Scala for Task 2.

\begin{enumerate}
\item Strongly disagree
\item Disagree
\item Neutral
\item Agree
\item Strongly Agree
\end{enumerate}

Rationale: in addition to objective analyses of task submissions, we want to know whether programmers subjectively prefer AFABL.

\item What was it about AFABL that made the Task 2 easier or harder?

Rationale: we want to get open-ended feedback for things we did not anticipate.

\end{enumerate}

\section{Evaluation}

Using results from the pilot study, we evaluated the internal consistency of the survey by calculating the Cronbach alpha coefficients for the following constructs:

\begin{enumerate}

\item User satisfaction with Scala for agent programming tasks.
\begin{itemize}
\item Questions 1 and 3
\end{itemize}

\item User satisfaction with AFABL for agent programming tasks.
\begin{itemize}
\item  Questions 2 and 4
\end{itemize}

\item User preference for AFABL over Scala for agent programming tasks.
\begin{itemize}
\item Questions 5 and 7
\end{itemize}

\end{enumerate}

The Cronbach alpha coefficient measures the correlation between the answers to questions that measure the same construct and is given by:

\[
\alpha = \frac{k}{k - 1} \times (1 - \frac{s_{T}^{2} - \sum s_{I}^{2}}{s_{T}^{2}})
\]

where
\begin{itemize}
\item $s_T^2$ is the total variance of all the items (questions) for a construct
\item $s_I^2$ is the variance of an individual item, and
\item $k$ is the number of items.
\end{itemize}

Typically a construct is considered valid if its Cronbach alpha coefficient is at least 0.7. As we report in Chapter \ref{ch:afabl-study}, all Cronbach alpha coefficients were greater than 1.

\section{Source Code Analysis}

The code submitted for each task was analyzed to determine:

\begin{itemize}
\item How much code was required for each task with and without AFABL.
\item How consistent the solutions were between programmers in each task with and without AFABL.  Did AFABL lead to more consistent designs?
\item How well the programmers understood the problem.
\end{itemize}

\section{Run-time Analysis}

The performance of the solutions submitted for each task was recorded for comparison. The purpose of this comparison was to determine how much effort was required to get good performance, not to get the best possible performance.

\subsection{Logistics}

The experiments were conducted online to provide easy access to the greatest number of participants.  Participants:

\begin{enumerate}
\item Register online with (optional) confidential identifying information.
\item Complete demographics survey.  The web application used the demographic survey to place participants in the Scala-first or AFABL-first groups.
\item Downloaded code and task instructions.
\item Completed Task 1 in Scala or AFABL.
\item Complete Task 2 in Scala or AFABL.
\item Submitted their solutions using our IntelliJ IDEA plug-in.
\item Completes a reflection survey.
\end{enumerate}
