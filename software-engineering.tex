\chapter{Background in Software Engineering}\label{ch:se}

This chapter provides background in software engineering that relates to our work. First we provide a brief overview of software engineering and discuss the challenges of sofware engineering and the ways those challenges are typically met to situate our work within the landscape of software engineering. Then we discuss empirical and analytical software engineering research methods which we will use evaluate AFABL in the next chapter -- programmer usage studies and software complexity measures. Finally we close with a discussion of adaptive programming.




\cite{gacek1995a-exploiting}


\cite{runeson2009a-guidelines}


\cite{shull2000a-investigating}


\cite{dmitriev2004a-language}





\section{Software Reuse}

Software reuse means means using an existing software artifact in a new software system, ideally without modifying the original artifact. Abstraction is important -- cognitive distance is an intuitive measure of the effort required in to reuse \cite{krueger1992a-software}.

\cite{gacek1995a-exploiting}


\cite{mili1995a-reusing}


\cite{frakes1996a-software}

\cite{frakes2005a-software}



\cite{basili1996a-how-reuse}





\cite{shiva2007a-software}


\cite{mohagheghi2008a-an-empirical}


\cite{lorenz2011a-code}


\subsection{APIs: Libraries and Frameworks}




\cite{polancic2010a-an-empirical}


\subsection{Domain-Specific Languages}

A domain-specific language (DSL) is a language that

Specialized programming languages were alredy widespread when Landin proposed the first unified framework for designing domain specific languages in 1966 \cite{landin1966next}. In Landin's framework the design of a DSL consists of two independent parts: the written form of the language, and the kinds of abstractions that can be expressed in the language.

Landin: Linguistic structure, syntax, semantic constraints on linguistic structure, outcome. Abstract syntax, axiomatization, and an underlying abstract machine.

Perhaps the most successful DSL, with which every reasonably literate software engineer or computer scientist is familiar, is Structured Query Language (SQL) \cite{}. SQL was originally presented as SEQUEL in 1974 by Chamberline and Boyce of IBM Research \cite{chamberlin1974sequel}. Today is used in all significant relational databases and is currently in its ANSI/ISO standard is on its third version. SQL has succeeded so completely becuase its syntax provides such a

Domain-specific languages provide two primary benefits: improving programmer productivity and improving communication with domain experts \cite{fowler2011domain}. In Chapter \ref{ch:afabl} we show that AFABL imporoves programmer productivity by reducing the effort required to write agents and reducing the complexity of agent code. In Chapter \ref{ch:application} we present an application of AFABL to the domain of personality modeling in psychology.

\cite{hudak1996building}
\cite{hudak1998modular}


\cite{lorenz2011a-code}


\cite{taha2008domain-specific}


\cite{deursen2000domain-specific}


\cite{dmitriev2004a-language}





\cite{mitchell1993on-abstraction}


\cite{odersky2008programming}


\cite{simpkins2008towards}


\cite{zang2007towards}


\cite{mernik2005when}


\section{Software Complexity}


\cite{mccabe1976complexity}


\cite{gill1991cyclomatic}


\cite{weyuker1988evaluating}


\cite{mccabe1989design}


\cite{kearney1986software}


\cite{shao2003new}



\section{Adaptive Programming}

By adaptive software we refer to the notion used in the machine learning community: software that learns to adapt to its environment during run-time, not software that is written to be easily changed by modifying the source code and recompiling.  In particular, we use Peter Norvig's definition of adaptive software:

\begin{quote}
Adaptive software uses available information about changes in its
environment to improve its behavior~\cite{norvig1998adaptive}.
\end{quote}

In this work we are particularly interested in programming intelligent agents that operate in real environments, and in virtual environments that are designed to simulate real environments.  Examples of these kinds of agents include robots, and non-player characters in interactive games and dramas.  Unlike traditional programs, agents operate in environments that are often incompletely perceived and constantly changing.  This incompleteness of perception and dynamism in the environment creates a strong need for adaptivity.  Programming this adaptivity by hand in a language that does not provide built-in support for adaptivity is very cumbersome.  This dissertation will contribute a programming language -- AFABL -- with built-in adaptivity and support for partial programming, making the construction of adaptive agents much easier.


\subsection{How to Achieve Adaptive Software}

Norvig identifies several requirements of adaptive soft\-ware---adaptive programming concerns, agent-oriented concerns, and software engineering concerns---and five key technologies---dynamic programming languages, agent technology, decision theory, reinforcement learning, and probabilistic networks---needed to realize adaptive software.  These requirements and technologies are embodied in his model of adaptive programming given in Table~\ref{tab:adaptive-model}.

\begin{table}[h]
\begin{tabular}{|c|c|}\hline
Traditional Programming & Adaptive Programming \\ \hline
Function/Class & Agent/Module \\
Input/Output & Perception/Action \\
Logic-based & Probability-based \\
Goal-based & Utility-based \\
Sequential, single- & Parallel, multi- \\
Hand-programmed & Trained (Learning) \\
Fidelity to designer & Perform well in environment \\
Pass test suite & Scientific method\\ \hline
\end{tabular}
\caption{Peter Norvig's model of adaptive programming
  ~\cite{norvig1998decision}.}
\label{tab:adaptive-model}
\end{table}

AFABL integrates two of Norvig's key technologies: agent technology and reinforcement learning.  This dissertation will explain how AFABL implements Norvig's adaptive programming model and argue that AFABL satisfies many of Norvig's requirements.

AFABL will be a framework and DSL embedded in Scala.  Implementing AFABL as an embedded DSL gives programmers the full power and expressivity of Scala.  In essence, AFABL is a modular RL-based agent programming framework and a set of idioms and design patterns for writing adaptive agents.  Using the term "language" to refer to this kind of solution is common in the literature \cite{andre2002state}.

This dissertation is interdisciplinary, containing elements of machine learning, programming languages, and software engineering.  To be credible this work must address language design issues relevant to practical programming problems, and it must provide a rigorous account of how the adaptive parts of AFABL implement reinforcement learning.

\subsection{The Partial Programming Paradigm}

The model of computation, or ``control regime,'' supported by a language is the fundamental semantics of language constructs that molds the way programmers think about programs. PROLOG provides a declarative semantics in which programmers express objects and constraints, and pose queries for which PROLOG can find proofs.  In C, programmers manipulate a complex state machine. Functional languages such as ML and Haskell are based on Lambda Calculus. AFABL, being a domain-specific language (DSL) \cite{hudak1996building} embedded in Scala \cite{odersky2008programming,odersky2005scalable} in Scala, will be multi-paradigmatic, supporting functional and object-oriented through its direct use of Scala, and partial programming semantics based on reinforcement learning, in which the programmer defines the agent's actions and allows the learning system to select them based on states and rewards.  This point is important: partial programming represents a new paradigm which results in a new way of writing programs that is much better suited to certain classes of problems, namely adaptive agents, than other programming paradigms.  AFABL facilitates adaptive agent programming in the same way that PROLOG facilitates logic programming.  While it is possible to write logic programs in a procedural language, it is much more natural and efficient to write logic programs in PROLOG.  The issue here is not Turing-completeness, the issue is cognitive load on the programmer.  In a Turing-complete language, writing a program for any decidable problem is theoretically possible, but is often practically impossible for certain classes of problems.  If this were not true then the whole enterprise of language design would have reached its end years ago.

The essential characteristic of partial programming that makes it the right paradigm for adaptive software is that it enables the separation of the ``what'' of agent behavior from the ``how'' in those cases where the ``how'' is either unknown or simply too cumbersome or difficult to write explicitly.  Returning to our PROLOG analogy, PROLOG programmers define elements of logical arguments.  The PROLOG system handles unification and backtracking search automatically, relieving the programmer from the need to think of such details. Similarly, in AFABL the programmer defines elements of behaviors -- states, actions, and rewards -- and leaves the language's runtime system to handle the details of how particular combinations of these elements determine the agent's behavior in a given state.  AFABL allows an agent programmer to think at a higher level of abstraction, ignoring details that are not relevant to defining an agent's behavior.  When writing an agent in AFABL, the primary task of the programmer is to define the actions that an agent can take, define whatever conditions are known to invoke certain behaviors, and define other behaviors as ``adaptive,'' that is, to be learned by the AFABL's integrated reinforcement learning.  This ability to program partial behaviors relieves a great deal of burden from the programmer and greatly simplifies the task of writing adaptive agents.  In Section \ref{sec:afabl-evaluation} we will see how AFABL implements its support for adaptivity and partial programming.


\section{ALisp}




\section{Adaptation-Based Programming}

Bauer's Ph.D. work in adaptation-based programming \cite{bauer2013adaptation} is the closest to ours in its focus on the practical application of adaptive programming. Bauer implemented libraries for automated adaptation as a Java library \cite{bauer2011adaptation} and as a Haskell embedded DSL \cite{bauer2011adaptation-haskell}. These systems used Q-learning internally but did not use modular reinforcement learning. Bauer also did not conduct empirical software engineering studies of programmers to quantify and qualify the benefits of integrating reinforcement learning into a programming language. In the next chapter we present our language, AFABL, which integrates modular reinforcement learning with the results of a programmer study whcih demonstrates its value.

\section{Software Engineering Experimentation}

Basili and colleagues have conducted many experiments and written extensively about the role of experiments in software engineering research and the kinds of knowledge that can be gained from experimentation \cite{basili2007role,basili1986a-experimentation}. In the next chapter we couch our programmer study of AFABL in their framework: Definition, Planning, Operation, and Interpretation. for software engineering experimentation. Review of . Framework:

Definition
---
Motivation - assess advantage of AFABL, validate language-integrated RL
Object - a programming language applied to a particular kin dof programming task
Purpose -evaluate
Perspective - user (of the programming language)
Domain - programmer
Scope - single project by single programmer

Planning
---
Design - Randomized
Criteria - size, complexity
Measurement - Metric validation, subjective reflection

Operation
---
Preparation - pilot study
Execution - data collection: online-delivered programming tasks
Analysis - quantitative: comparison of complexity metrics, complexities; qualitative

Interpretation
---
Statistical framework - t-test
Extrapolation -
Impact


Buse and colleagues, Benefits and Barriers of User Evaluation in SOftware Engineering Research \cite{buse2011a-benefits}
