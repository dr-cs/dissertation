\chapter{Background in Software Engineering}\label{ch:se}

This chapter provides background in software engineering that relates to our work. First we provide a brief overview of software engineering and discuss the challenges of sofware engineering and the ways those challenges are typically met to situate our work within the landscape of software engineering. Then we discuss empirical and analytical software engineering research methods which we will use evaluate AFABL in the next chapter -- programmer usage studies and software complexity measures. Finally we close with a discussion of adaptive programming.

\cite{polancic2010a-an-empirical}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders.

\cite{buse2011a-benefits}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders.

\cite{lorenz2011a-code}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{basili1986a-experimentation}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{gacek1995a-exploiting}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{runeson2009a-guidelines}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{shull2000a-investigating}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{dmitriev2004a-language}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{,basili2007role}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\section{Software Reuse}

Software reuse means means using an existing software artifact in a new software system without modification of the original artifact \cite{krueger1992a-software}.

\cite{gacek1995a-exploiting}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{mili1995a-reusing}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{frakes1996a-software}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{basili1996a-how-reuse}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{frakes2005a-software}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{shiva2007a-software}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{mohagheghi2008a-an-empirical}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{lorenz2011a-code}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\subsection{APIs: Libraries and Frameworks}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders


This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{polancic2010a-an-empirical}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\subsection{Domain-Specific Languages}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{hudak1996building}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{lorenz2011a-code}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{taha2008domain-specific}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{deursen2000domain-specific}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{dmitriev2004a-language}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{hudak1998modular}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{spinellis2001notable}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{mitchell1993on-abstraction}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{odersky2008programming}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{simpkins2008towards}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{zang2007towards}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{mernik2005when}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\section{Software Complexity}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{mccabe1976complexity}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{gill1991cyclomatic}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{weyuker1988evaluating}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{mccabe1989design}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{kearney1986software}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders

\cite{shao2003new}

This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders


\section{Adaptive Programming}

By adaptive software we refer to the notion used in the machine learning community: software that learns to adapt to its environment during run-time, not software that is written to be easily changed by modifying the source code and recompiling.  In particular, we use Peter Norvig's definition of adaptive software:

\begin{quote}
Adaptive software uses available information about changes in its
environment to improve its behavior~\cite{norvig1998adaptive}.
\end{quote}

In this work we are particularly interested in programming intelligent agents that operate in real environments, and in virtual environments that are designed to simulate real environments.  Examples of these kinds of agents include robots, and non-player characters in interactive games and dramas.  Unlike traditional programs, agents operate in environments that are often incompletely perceived and constantly changing.  This incompleteness of perception and dynamism in the environment creates a strong need for adaptivity.  Programming this adaptivity by hand in a language that does not provide built-in support for adaptivity is very cumbersome.  This dissertation will contribute a programming language -- AFABL -- with built-in adaptivity and support for partial programming, making the construction of adaptive agents much easier.


\subsection{How to Achieve Adaptive Software}

Norvig identifies several requirements of adaptive
soft\-ware---adaptive programming concerns, agent-oriented concerns,
and software engineering concerns---and five key
technologies---dynamic programming languages, agent technology,
decision theory, reinforcement learning, and probabilistic
networks---needed to realize adaptive software.  These requirements
and technologies are embodied in his model of adaptive programming
given in Table~\ref{tab:adaptive-model}.

\begin{table}[h]
\begin{tabular}{|c|c|}\hline
Traditional Programming & Adaptive Programming \\ \hline
Function/Class & Agent/Module \\
Input/Output & Perception/Action \\
Logic-based & Probability-based \\
Goal-based & Utility-based \\
Sequential, single- & Parallel, multi- \\
Hand-programmed & Trained (Learning) \\
Fidelity to designer & Perform well in environment \\
Pass test suite & Scientific method\\ \hline
\end{tabular}
\caption{Peter Norvig's model of adaptive programming
  ~\cite{norvig1998decision}.}
\label{tab:adaptive-model}
\end{table}

AFABL integrates two of Norvig's key technologies: agent technology and reinforcement learning.  This dissertation will explain how AFABL implements Norvig's adaptive programming model and argue that AFABL satisfies many of Norvig's requirements.

AFABL will be a framework and DSL embedded in Scala.  Implementing AFABL as an embedded DSL gives programmers the full power and expressivity of Scala.  In essence, AFABL is a modular RL-based agent programming framework and a set of idioms and design patterns for writing adaptive agents.  Using the term "language" to refer to this kind of solution is common in the literature \cite{andre2002state}.

This dissertation is interdisciplinary, containing elements of machine learning, programming languages, and software engineering.  To be credible this work must address language design issues relevant to practical programming problems, and it must provide a rigorous account of how the adaptive parts of AFABL implement reinforcement learning.

\subsection{The Partial Programming Paradigm}

The model of computation, or ``control regime,'' supported by a language is the fundamental semantics of language constructs that molds the way programmers think about programs. PROLOG provides a declarative semantics in which programmers express objects and constraints, and pose queries for which PROLOG can find proofs.  In C, programmers manipulate a complex state machine. Functional languages such as ML and Haskell are based on Lambda Calculus. AFABL, being a domain-specific language (DSL) \cite{hudak1996building} embedded in Scala \cite{odersky2008programming,odersky2005scalable} in Scala, will be multi-paradigmatic, supporting functional and object-oriented through its direct use of Scala, and partial programming semantics based on reinforcement learning, in which the programmer defines the agent's actions and allows the learning system to select them based on states and rewards.  This point is important: partial programming represents a new paradigm which results in a new way of writing programs that is much better suited to certain classes of problems, namely adaptive agents, than other programming paradigms.  AFABL facilitates adaptive agent programming in the same way that PROLOG facilitates logic programming.  While it is possible to write logic programs in a procedural language, it is much more natural and efficient to write logic programs in PROLOG.  The issue here is not Turing-completeness, the issue is cognitive load on the programmer.  In a Turing-complete language, writing a program for any decidable problem is theoretically possible, but is often practically impossible for certain classes of problems.  If this were not true then the whole enterprise of language design would have reached its end years ago.

The essential characteristic of partial programming that makes it the right paradigm for adaptive software is that it enables the separation of the ``what'' of agent behavior from the ``how'' in those cases where the ``how'' is either unknown or simply too cumbersome or difficult to write explicitly.  Returning to our PROLOG analogy, PROLOG programmers define elements of logical arguments.  The PROLOG system handles unification and backtracking search automatically, relieving the programmer from the need to think of such details. Similarly, in AFABL the programmer defines elements of behaviors -- states, actions, and rewards -- and leaves the language's runtime system to handle the details of how particular combinations of these elements determine the agent's behavior in a given state.  AFABL allows an agent programmer to think at a higher level of abstraction, ignoring details that are not relevant to defining an agent's behavior.  When writing an agent in AFABL, the primary task of the programmer is to define the actions that an agent can take, define whatever conditions are known to invoke certain behaviors, and define other behaviors as ``adaptive,'' that is, to be learned by the AFABL's integrated reinforcement learning.  This ability to program partial behaviors relieves a great deal of burden from the programmer and greatly simplifies the task of writing adaptive agents.  In Section \ref{sec:afabl-evaluation} we will see how AFABL implements its support for adaptivity and partial programming.


\section{ALisp}


This is a holder sentence meant to fill in the space that will likely be taken by the stuff I'm going to write about the reference citations places here as placeholders and reminders


\section{Adaptation-Based Programming}

Bauer's Ph.D. work in adaptation-based programming \cite{bauer2013adaptation} is the closest to ours in its focus on the practical application of adaptive programming. Bauer implemented libraries for automated adaptation as a Java library \cite{bauer2011adaptation} and as a Haskell embedded DSL \cite{bauer2011adaptation-haskell}. These systems used Q-learning internally but did use modular reinforcement learning. Bauer also did not conduct empirical software engineering studies of programmers to quantify and qualify the benefits of integrating reinforcement learning into a programming language. In the next chapter we present our language, AFABL, which integrates modular reinforcement learning with the results of a programmer study whcih demonstrates its value.
